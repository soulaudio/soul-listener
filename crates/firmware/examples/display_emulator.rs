//! DAP Display Emulator
//!
//! Blank canvas for developing the DAP UI.
//! Run with: cargo run --example display_emulator --features emulator
//!
//! # Hot-Reload Mode
//!
//! For true in-process hot-reload (window stays open on code changes):
//!
//! Step 1: cargo build --package firmware-ui --features hot-reload
//! Step 2: cargo run --example display_emulator --features emulator,hot-reload
//!
//! Rendering code lives in: crates/firmware-ui/src/render.rs
//! Edit that file, save, and the emulator reloads without restart.
//!
//! # Kill-and-Restart Mode (default: xtask dev)
//!
//! Without the hot-reload feature, xtask dev uses kill-and-restart.
//! That mode works for all code changes (not just render.rs).

use embedded_graphics::pixelcolor::Gray4;
use embedded_graphics::prelude::*;
use embedded_graphics::primitives::{PrimitiveStyle, Rectangle};

use firmware::EmulatorDisplay;
use platform::config;

// The #[hot_module] attribute macro (hot-lib-reloader 0.8) generates
// a mod with hot-reloadable wrappers for the dylib functions.
// Build the dylib FIRST: cargo build --package firmware-ui --features hot-reload
//
// C ABI boundary uses eink_emulator::Emulator (not EmulatorDisplay)
// to avoid circular dep: firmware -> firmware-ui -> firmware.
// We pass display.emulator_mut() as raw pointer to the dylib.
#[cfg(feature = "hot-reload")]
#[hot_lib_reloader::hot_module(dylib = "firmware_ui")]
mod hot_ui {
    hot_functions_from_file!("crates/firmware-ui/src/lib.rs");

    #[lib_change_subscription]
    pub fn subscribe() -> hot_lib_reloader::LibReloadObserver {}
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize logger. Controlled by RUST_LOG env var (default: info).
    // cargo dev sets RUST_LOG=info automatically; override with e.g. RUST_LOG=debug cargo dev.
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
        .format_timestamp_secs()
        .init();

    log::info!("{} - Display Emulator starting", config::APP_NAME);
    println!("{} - Display Emulator", config::APP_NAME);
    println!("Display: GDEM0397T81P 3.97\" E-Ink (800x480 -> 480x800 portrait)\n");

    let rt = tokio::runtime::Runtime::new()?;

    let emulator_config = eink_emulator::EmulatorConfig {
        rotation: eink_emulator::Rotation::Degrees90,
        scale: 1,
    };

    let mut display =
        EmulatorDisplay::with_spec_and_config(&firmware::GDEM0397T81P_SPEC, emulator_config);
    println!("Window opened - Portrait mode (480x800), native resolution\n");

    // Attach keyboard/scroll input before initializing so the queue is wired
    // through to the window event loop when run() is called.
    // Not used in hot-reload mode (which has its own render loop).
    #[cfg(all(feature = "keyboard-input", not(feature = "hot-reload")))]
    let mut input = display.emulator_mut().input_receiver();

    println!("Initializing display...");
    rt.block_on(async { display.emulator_mut().initialize().await })
        .map_err(|e| Box::<dyn std::error::Error>::from(e.to_string()))?;

    use platform::DisplayDriver;
    println!("Display ready\n");

    #[cfg(feature = "debug")]
    {
        println!("DEBUG MODE ENABLED");
        println!("Hotkeys: Ctrl+1 panel | Ctrl+2 borders | Ctrl+3 inspector");
        println!();
    }

    #[cfg(all(feature = "keyboard-input", not(feature = "hot-reload")))]
    {
        println!("KEYBOARD INPUT ENABLED");
        println!("  Space / K      = Play/Pause");
        println!("  ← / J / ,      = Previous");
        println!("  → / L / .      = Next");
        println!("  ↑ / =          = Volume up");
        println!("  ↓ / -          = Volume down");
        println!("  M              = Menu");
        println!("  Backspace / Esc= Back");
        println!("  Enter          = Select");
        println!("  Scroll wheel   = Encoder");
        println!();
    }

    // True in-process hot-reload path.
    // hot_ui module was generated by #[hot_module] above.
    // wait_for_reload() blocks until the dylib is reloaded.
    #[cfg(feature = "hot-reload")]
    {
        use std::time::{Duration, Instant};

        println!("HOT-RELOAD MODE ACTIVE");
        println!("Rendering code: crates/firmware-ui/src/render.rs");
        println!("Edit render.rs and save to see changes instantly!\n");

        let mut last_version = hot_ui::ui_version();

        // ABI version guard: panic early if the loaded dylib was compiled with a
        // different ABI than what this binary expects.
        let dylib_abi = hot_ui::ui_abi_version();
        assert_eq!(
            dylib_abi,
            firmware_ui::ABI_VERSION,
            "hot-reload ABI mismatch: binary expects ABI v{}, dylib reports v{}. \
             Rebuild firmware-ui with: cargo build -p firmware-ui --features hot-reload",
            firmware_ui::ABI_VERSION,
            dylib_abi,
        );
        println!("Initial render...");
        // SAFETY: display.emulator_mut() is valid, non-null, exclusively owned.
        // Unwrapping EmulatorDisplay to its inner Emulator avoids circular dep.
        // Verified: ui_abi_version() == firmware_ui::ABI_VERSION (asserted above).
        unsafe { hot_ui::render_ui(display.emulator_mut() as *mut eink_emulator::Emulator) };
        rt.block_on(async { display.refresh_full().await })?;
        println!("Ready. Edit crates/firmware-ui/src/render.rs to hot-reload.\n");

        // Subscribe to reload events and block until each reload completes.
        let observer = hot_ui::subscribe();
        loop {
            observer.wait_for_reload();
            let new_version = hot_ui::ui_version();
            if new_version != last_version {
                last_version = new_version;
                println!("Hot-reloaded firmware_ui dylib");

                let size = display.bounding_box().size;
                Rectangle::new(Point::zero(), size)
                    .into_styled(PrimitiveStyle::with_fill(Gray4::WHITE))
                    .draw(&mut display)?;
                // SAFETY: display.emulator_mut() is valid, non-null, exclusively owned.
                unsafe {
                    hot_ui::render_ui(display.emulator_mut() as *mut eink_emulator::Emulator)
                };
                rt.block_on(async { display.refresh_full().await })?;
                println!("Reload complete at {:?}", Instant::now());
            }
        }
    }

    // Standard (non-hot-reload) path.
    // xtask dev kill-and-restart mode uses this path.
    #[cfg(not(feature = "hot-reload"))]
    {
        println!("Rendering demo menu...");
        render_demo_menu(&mut display)?;
        rt.block_on(async { display.refresh_full().await })?;

        // Register named DAP scene components so the debug inspector tree
        // shows meaningful names instead of raw coordinates.
        #[cfg(feature = "debug")]
        register_dap_components(&mut display);

        println!("Demo menu rendered\n");
        println!("Close the window to exit.\n");

        // Spawn a background task that logs every input event to stdout.
        // This runs concurrently with the blocking winit event loop via the
        // multi-thread tokio runtime.
        #[cfg(all(feature = "keyboard-input", not(feature = "hot-reload")))]
        rt.spawn(async move {
            use platform::InputDevice as _;
            loop {
                let ev = input.wait_for_event().await;
                log::info!("[input] {:?}", ev);
            }
        });

        display.into_inner().run();
    }

    Ok(())
}

/// Register named DAP scene components with the debug inspector.
///
/// Positions are in the display's native coordinate space (landscape 800×480
/// before the 90° portrait rotation applied at render time). The debug panel's
/// scene tree will show these names instead of raw coordinates.
///
/// Must be called AFTER the initial `refresh_full()` and BEFORE `run()` so
/// the registration is transferred to the window's debug manager.
#[cfg(all(not(feature = "hot-reload"), feature = "debug"))]
fn register_dap_components(display: &mut EmulatorDisplay) {
    use eink_emulator::debug::state::{ComponentInfo, Spacing};

    let Some(dm) = display.emulator_mut().debug_manager_mut() else {
        return;
    };
    let state = dm.state_mut();
    state.clear_registered_components();

    // Root screen container (full display bounds)
    state.register_component(ComponentInfo {
        component_type: "Container".to_string(),
        position: (0, 0),
        size: (800, 480),
        test_id: Some("dap-screen".to_string()),
        ..Default::default()
    });

    // Header bar (top 60px)
    state.register_component(ComponentInfo {
        component_type: "Container".to_string(),
        position: (0, 0),
        size: (800, 60),
        test_id: Some("dap-header".to_string()),
        padding: Spacing::axes(8, 20),
        ..Default::default()
    });

    // Main menu content area
    state.register_component(ComponentInfo {
        component_type: "Container".to_string(),
        position: (0, 60),
        size: (800, 380),
        test_id: Some("dap-menu".to_string()),
        padding: Spacing::all(10),
        ..Default::default()
    });

    // Menu items — match render_demo_menu layout: y = 100 + idx*50, h=45
    let menu_items = [
        "menu-now-playing",
        "menu-library",
        "menu-playlists",
        "menu-settings",
        "menu-about",
    ];
    for (idx, name) in menu_items.iter().enumerate() {
        let y = 95 + (idx as i32 * 50);
        state.register_component(ComponentInfo {
            component_type: "Button".to_string(),
            position: (10, y),
            size: (780, 45),
            test_id: Some((*name).to_string()),
            padding: Spacing::axes(8, 12),
            border: Spacing::all(1),
            attributes: vec![
                ("index".to_string(), idx.to_string()),
                ("enabled".to_string(), "true".to_string()),
            ],
            ..Default::default()
        });
    }

    // Footer label
    state.register_component(ComponentInfo {
        component_type: "Label".to_string(),
        position: (0, 440),
        size: (800, 40),
        test_id: Some("dap-footer".to_string()),
        ..Default::default()
    });
}

/// Render a simple demo menu (non-hot-reload path only).
///
/// When hot-reload is enabled this function is NOT used.
/// Edit crates/firmware-ui/src/render.rs instead.
#[cfg(not(feature = "hot-reload"))]
fn render_demo_menu<D>(display: &mut D) -> Result<(), D::Error>
where
    D: DrawTarget<Color = Gray4>,
{
    use embedded_graphics::mono_font::{ascii::FONT_10X20, MonoTextStyle};
    use embedded_graphics::text::Text;

    let size = display.bounding_box().size;

    Rectangle::new(Point::zero(), Size::new(size.width, 60))
        .into_styled(PrimitiveStyle::with_fill(Gray4::new(0x2)))
        .draw(display)?;

    let header_style = MonoTextStyle::new(&FONT_10X20, Gray4::WHITE);
    Text::new("Main Menu", Point::new(20, 35), header_style).draw(display)?;

    let menu_style = MonoTextStyle::new(&FONT_10X20, Gray4::BLACK);
    let menu_items = [
        "1. Now Playing",
        "2. Library",
        "3. Playlists",
        "4. Settings",
        "5. About",
    ];

    for (idx, item) in menu_items.iter().enumerate() {
        let y = 100 + (idx as i32 * 50);
        if idx % 2 == 0 {
            Rectangle::new(Point::new(10, y - 5), Size::new(size.width - 20, 45))
                .into_styled(PrimitiveStyle::with_fill(Gray4::new(0xE)))
                .draw(display)?;
        }
        Text::new(item, Point::new(30, y + 20), menu_style).draw(display)?;
    }

    let footer_style = MonoTextStyle::new(&FONT_10X20, Gray4::new(0x8));
    Text::new(
        "Replace this with your UI in display_emulator.rs",
        Point::new(30, (size.height - 30) as i32),
        footer_style,
    )
    .draw(display)?;

    Ok(())
}
