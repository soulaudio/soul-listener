//! Storage peripheral configuration for SoulAudio DAP.
//!
//! Covers SDMMC1 (microSD) and QUADSPI (NOR flash) configuration as typed
//! structs. For individual QSPI constants (used for PAC-level register writes),
//! see [`crate::qspi_config`].

/// SDMMC1 configuration for microSD card.
///
/// STM32H743ZI uses SDMMC1 with IDMA (internal DMA, not DMA1/2).
/// The IDMA is built into the SDMMC peripheral itself — no external
/// DMA channel assignment is needed.
///
/// # Clock Source
///
/// SDMMC1 requires HSI48 enabled before `embassy_stm32::init()`.
/// See [`crate::clock_config::SOUL_AUDIO_CLOCK_REQUIREMENTS`] and
/// embassy-stm32 issue #3049.
pub struct SdmmcConfig {
    /// Bus width in bits (4 = 4-bit SDIO mode, required for UHS-I).
    pub bus_width: u8,
    /// Maximum clock frequency in Hz.
    pub max_clock_hz: u32,
    /// Data transfer timeout in milliseconds.
    pub transfer_timeout_ms: u32,
}

impl SdmmcConfig {
    /// Standard configuration for microSD UHS-I (4-bit, 50 MHz).
    ///
    /// Uses 4-bit bus mode as required by SDIO UHS-I specification.
    /// Clock of 50 MHz is the SD specification limit for UHS-I SDR50 mode.
    /// Timeout of 1 000 ms accommodates the worst-case SD card init sequence
    /// (up to ~400 ms per the SD spec, with margin for retries).
    pub fn microsd_uhs_i() -> Self {
        Self {
            bus_width: 4,
            max_clock_hz: 50_000_000, // 50 MHz for UHS-I SDR50
            transfer_timeout_ms: 1_000,
        }
    }
}

/// GPIO pin assignments for SDMMC1 on STM32H743ZI LQFP144.
///
/// All pins use Alternate Function 12 (AF12) as specified in the
/// STM32H743ZI datasheet (DS12110 Rev 9, Table 11 — Alternate function mapping).
///
/// # DMA Note
///
/// SDMMC1 uses IDMA (internal DMA built into the peripheral) — **not** DMA1/DMA2.
/// No external DMA channel assignment is required.
///
/// # Clock Note
///
/// `SDMMC1_CK` is generated by the SDMMC peripheral from its kernel clock.
/// Kernel clock source = PLL1Q (200 MHz via `build_embassy_config()`),
/// divided internally to the configured frequency (≤ 50 MHz for UHS-I).
pub struct SdmmcPins;

impl SdmmcPins {
    /// SDMMC1_CK — clock output. Pin: PC12, AF12.
    pub const CLK_PIN: &'static str = "PC12_AF12";
    /// SDMMC1_CMD — command line. Pin: PD2, AF12.
    pub const CMD_PIN: &'static str = "PD2_AF12";
    /// SDMMC1_D0 — data bit 0. Pin: PC8, AF12.
    pub const D0_PIN: &'static str = "PC8_AF12";
    /// SDMMC1_D1 — data bit 1. Pin: PC9, AF12.
    pub const D1_PIN: &'static str = "PC9_AF12";
    /// SDMMC1_D2 — data bit 2. Pin: PC10, AF12.
    pub const D2_PIN: &'static str = "PC10_AF12";
    /// SDMMC1_D3 — data bit 3 / card detect (active low). Pin: PC11, AF12.
    pub const D3_PIN: &'static str = "PC11_AF12";
}

/// QUADSPI NOR flash configuration for W25Q128JV (16 MB, 133 MHz max).
///
/// This struct wraps the individual constants from [`crate::qspi_config`]
/// into a typed configuration object for use in init stubs and documentation.
///
/// # Embassy / PAC Note
///
/// Embassy-stm32 issue #3149: `embassy_stm32::qspi` does not implement
/// memory-mapped (XiP) mode. XiP must be enabled via PAC-level register writes.
/// See [`crate::qspi_config`] for the individual register field values and the
/// `QSPI_INIT_NOTE` in `firmware::boot` for the full configuration sequence.
pub struct QspiNorConfig {
    /// AHB prescaler: QSPI_CLK = AHB_CLK / (prescaler + 1).
    ///
    /// At 200 MHz AHB: prescaler = 1 → 100 MHz (within W25Q128JV 133 MHz spec).
    /// At 240 MHz AHB: prescaler = 1 → 120 MHz (within W25Q128JV 133 MHz spec).
    pub prescaler: u8,
    /// Flash size field for `QUADSPI_DCR.FSIZE`.
    ///
    /// Hardware formula: addressable bytes = 2^(flash_size_field + 1).
    /// W25Q128JV = 16 MB = 2^24 bytes → field = 23.
    pub flash_size_field: u8,
    /// Number of dummy cycles for Fast Read Quad I/O (command 0xEB).
    ///
    /// W25Q128JV requires 4 dummy cycles at speeds ≥ 80 MHz.
    pub dummy_cycles: u8,
    /// Fast Read Quad I/O command byte.
    ///
    /// 0xEB = Fast Read Quad I/O: highest-throughput single-chip read mode.
    pub read_cmd: u8,
}

impl QspiNorConfig {
    /// Configuration for W25Q128JV (16 MB) at 100 MHz via AHB/2.
    ///
    /// Uses prescaler = 1 so QSPI_CLK = AHB / 2. At 200 MHz AHB this yields
    /// 100 MHz, comfortably within the W25Q128JV 133 MHz maximum.
    ///
    /// The Fast Read Quad I/O command (0xEB) with 4 dummy cycles gives maximum
    /// read throughput in quad-wire mode.
    pub fn w25q128jv_at_100mhz() -> Self {
        Self {
            prescaler: 1,
            flash_size_field: 23,
            dummy_cycles: 4,
            read_cmd: 0xEB, // Fast Read Quad I/O
        }
    }

    /// Returns actual QUADSPI clock frequency given the AHB bus frequency.
    ///
    /// Formula: `ahb_hz / (prescaler + 1)`
    pub fn clock_hz(&self, ahb_hz: u32) -> u32 {
        ahb_hz / (u32::from(self.prescaler) + 1)
    }

    /// Returns actual flash size in bytes.
    ///
    /// Formula: `2^(flash_size_field + 1)`
    pub fn flash_size_bytes(&self) -> u32 {
        1u32 << (self.flash_size_field + 1)
    }
}

// ─── Tests ───────────────────────────────────────────────────────────────────

#[cfg(test)]
#[allow(
    clippy::assertions_on_constants,
    clippy::expect_used,
    clippy::unwrap_used
)]
mod tests {
    use super::*;

    #[test]
    fn sdmmc_config_4bit_mode() {
        let cfg = SdmmcConfig::microsd_uhs_i();
        assert_eq!(cfg.bus_width, 4, "SDMMC must use 4-bit mode for UHS-I");
    }

    #[test]
    fn sdmmc_config_50mhz_clock() {
        let cfg = SdmmcConfig::microsd_uhs_i();
        assert_eq!(cfg.max_clock_hz, 50_000_000);
    }

    #[test]
    fn sdmmc_config_timeout_is_reasonable() {
        let cfg = SdmmcConfig::microsd_uhs_i();
        assert!(
            cfg.transfer_timeout_ms >= 500,
            "transfer timeout must be >= 500ms"
        );
        assert!(
            cfg.transfer_timeout_ms <= 5_000,
            "transfer timeout must be <= 5s"
        );
    }

    #[test]
    fn sdmmc_clk_pin_is_pc12() {
        assert!(SdmmcPins::CLK_PIN.starts_with("PC12"));
    }

    #[test]
    fn sdmmc_cmd_pin_is_pd2() {
        assert!(SdmmcPins::CMD_PIN.starts_with("PD2"));
    }

    #[test]
    fn qspi_prescaler_gives_100mhz_at_200mhz_ahb() {
        let cfg = QspiNorConfig::w25q128jv_at_100mhz();
        assert_eq!(cfg.clock_hz(200_000_000), 100_000_000);
    }

    #[test]
    fn qspi_flash_size_is_16mb() {
        let cfg = QspiNorConfig::w25q128jv_at_100mhz();
        assert_eq!(cfg.flash_size_bytes(), 16 * 1024 * 1024);
    }

    #[test]
    fn qspi_read_cmd_is_fast_read_quad() {
        let cfg = QspiNorConfig::w25q128jv_at_100mhz();
        assert_eq!(
            cfg.read_cmd, 0xEB,
            "must use Fast Read Quad I/O (0xEB) for max throughput"
        );
    }

    #[test]
    fn qspi_100mhz_within_w25q128jv_spec() {
        let cfg = QspiNorConfig::w25q128jv_at_100mhz();
        let clock = cfg.clock_hz(200_000_000);
        assert!(
            clock <= 133_000_000,
            "QSPI clock {clock} Hz exceeds W25Q128JV maximum 133 MHz"
        );
    }
}
