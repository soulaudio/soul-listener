# Input module — Rotary encoder + push-buttons
#
# Mirrors: crates/platform/src/gpio.rs (InputDevice trait)
#          crates/firmware/src/input/ (encoder task, button task)
#
# Rotary encoder: EC11 or ALPS EC11E series (20 PPR, push-to-click)
#   Two quadrature outputs (A/B) + integrated push switch (SW)
#   Hardware debounce: 100 nF filter caps on A, B, and SW lines
#   MCU decodes in software using quadrature decoder or interrupt-based logic
#
# Buttons: Tactile SMD switches (e.g., C&K PTS526 or Würth 434121025816)
#   4 navigation/function buttons + 1 power button (long-press handled in firmware)
#   Active low (pulled to 3.3 V; switch pulls to GND)
#
# Power button: connected to WKUP pin on STM32H743 for wake-from-standby

from "interfaces.ato" import EncoderBus

module Input:
    """
    Rotary encoder and button inputs with hardware debouncing.
    All inputs use active-low logic with 10 kΩ pull-ups to 3.3 V.
    """

    # ── Ports ─────────────────────────────────────────────────────────────────
    power_3v3 = new ElectricPower  # 3.3 V supply for pull-ups
    encoder   = new EncoderBus     # Quadrature A/B + SW to MCU GPIOs

    # ── Rotary Encoder ────────────────────────────────────────────────────────
    # EC11 footprint: 5-pin (A, GND, B, GND, SW) — verify with chosen part
    enc = new Component  # Replace with EC11 component stub when sourced

    # Pull-ups for encoder A and B outputs (10 kΩ to 3.3 V)
    r_enc_a = new Resistor; r_enc_a.resistance = 10kohm +/- 5%; r_enc_a.package = "0402"
    r_enc_b = new Resistor; r_enc_b.resistance = 10kohm +/- 5%; r_enc_b.package = "0402"
    r_enc_sw = new Resistor; r_enc_sw.resistance = 10kohm +/- 5%; r_enc_sw.package = "0402"
    power_3v3.hv ~ r_enc_a.p1;  r_enc_a.p2  ~ encoder.enc_a
    power_3v3.hv ~ r_enc_b.p1;  r_enc_b.p2  ~ encoder.enc_b
    power_3v3.hv ~ r_enc_sw.p1; r_enc_sw.p2 ~ encoder.enc_sw

    # Hardware debounce caps: 100 nF to GND on each line (RC with pull-up)
    # f_cutoff = 1 / (2π × 10kΩ × 100nF) ≈ 160 Hz — eliminates contact bounce
    c_enc_a  = new Capacitor; c_enc_a.capacitance  = 100nF +/- 20%; c_enc_a.package  = "0402"
    c_enc_b  = new Capacitor; c_enc_b.capacitance  = 100nF +/- 20%; c_enc_b.package  = "0402"
    c_enc_sw = new Capacitor; c_enc_sw.capacitance = 100nF +/- 20%; c_enc_sw.package = "0402"
    encoder.enc_a  ~ c_enc_a.p1;  c_enc_a.p2  ~ power_3v3.lv
    encoder.enc_b  ~ c_enc_b.p1;  c_enc_b.p2  ~ power_3v3.lv
    encoder.enc_sw ~ c_enc_sw.p1; c_enc_sw.p2 ~ power_3v3.lv

    # ── Navigation Buttons ────────────────────────────────────────────────────
    # 4 tactile buttons: Play/Pause, Previous, Next, Menu
    # Active low: button connects line to GND; pull-up holds line high at rest
    btn_play = new Component  # Tactile switch — e.g., C&K PTS526
    btn_prev = new Component
    btn_next = new Component
    btn_menu = new Component

    # Pull-up resistors (10 kΩ each)
    r_play = new Resistor; r_play.resistance = 10kohm +/- 5%; r_play.package = "0402"
    r_prev = new Resistor; r_prev.resistance = 10kohm +/- 5%; r_prev.package = "0402"
    r_next = new Resistor; r_next.resistance = 10kohm +/- 5%; r_next.package = "0402"
    r_menu = new Resistor; r_menu.resistance = 10kohm +/- 5%; r_menu.package = "0402"
    power_3v3.hv ~ r_play.p1; r_play.p2 ~ encoder.btn_play
    power_3v3.hv ~ r_prev.p1; r_prev.p2 ~ encoder.btn_prev
    power_3v3.hv ~ r_next.p1; r_next.p2 ~ encoder.btn_next
    power_3v3.hv ~ r_menu.p1; r_menu.p2 ~ encoder.btn_menu

    # Debounce caps for buttons (100 nF each)
    c_play = new Capacitor; c_play.capacitance = 100nF +/- 20%; c_play.package = "0402"
    c_prev = new Capacitor; c_prev.capacitance = 100nF +/- 20%; c_prev.package = "0402"
    c_next = new Capacitor; c_next.capacitance = 100nF +/- 20%; c_next.package = "0402"
    c_menu = new Capacitor; c_menu.capacitance = 100nF +/- 20%; c_menu.package = "0402"
    encoder.btn_play ~ c_play.p1; c_play.p2 ~ power_3v3.lv
    encoder.btn_prev ~ c_prev.p1; c_prev.p2 ~ power_3v3.lv
    encoder.btn_next ~ c_next.p1; c_next.p2 ~ power_3v3.lv
    encoder.btn_menu ~ c_menu.p1; c_menu.p2 ~ power_3v3.lv

    # ── Power Button ──────────────────────────────────────────────────────────
    # Connected to STM32H743 PC13/WKUP pin for wake-from-standby
    # Long-press logic handled in firmware (PowerManager)
    btn_pwr = new Component
    r_pwr = new Resistor; r_pwr.resistance = 10kohm +/- 5%; r_pwr.package = "0402"
    c_pwr = new Capacitor; c_pwr.capacitance = 100nF +/- 20%; c_pwr.package = "0402"
    power_3v3.hv ~ r_pwr.p1; r_pwr.p2 ~ encoder.btn_power
    encoder.btn_power ~ c_pwr.p1; c_pwr.p2 ~ power_3v3.lv
    # Note: btn_pwr switch connects btn_power line to GND when pressed

    # ── Validation ────────────────────────────────────────────────────────────
    assert power_3v3.voltage within 2.7V to 3.6V
