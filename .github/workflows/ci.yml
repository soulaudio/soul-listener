# CI — SoulAudio DAP (Embedded Rust)
#
# Badge URL (add to README.md):
#   [![CI](https://github.com/yourusername/soulaudio-dap/actions/workflows/ci.yml/badge.svg)](https://github.com/yourusername/soulaudio-dap/actions/workflows/ci.yml)
#
# Job overview:
#   fmt            – cargo fmt check (all crates, host)
#   clippy         – cargo clippy for emulator feature set (host, std)
#   test           – cargo test per crate (host, avoids hardware/emulator conflicts)
#   check-emulator – cargo check -p firmware with emulator+debug+keyboard-input
#   check-embedded – cargo check -p firmware --target thumbv7em-none-eabihf --features hardware
#   check-no-std   – cargo check per embedded crate --target thumbv7em-none-eabihf --no-default-features
#
# NOTE on feature flag exclusivity:
#   `hardware` and `emulator` are mutually exclusive. `hardware` pulls in cortex-m/
#   defmt/probe-rs dependencies that require an ARM linker and no-std. `emulator`
#   pulls in tokio and winit which require std. Never use --all-features across the
#   firmware crate — it will fail to compile on both host and embedded targets.
#
# All GitHub Actions are pinned to exact commit SHAs for supply-chain security.
# To update a pinned action:
#   1. Find the new release tag at github.com/<owner>/<repo>/releases
#   2. Get the commit SHA: git ls-remote https://github.com/<owner>/<repo> refs/tags/<tag>
#   3. Update the SHA below and the version comment
#
# Current pins (as of 2026-02-20):
#   actions/checkout          v4.2.2   11bd71901bbe5b1630ceea73d27597364c9af683
#   Swatinem/rust-cache       v2.8.2   779680da715d629ac1d338a641029a2f4372abb5
#   dtolnay/rust-toolchain    @stable  (not SHA-pinnable: action reads channel
#                                       from the git ref name; @stable is the
#                                       correct moving tag as designed by the author)

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  CARGO_TERM_COLOR: always
  # Treat all warnings as errors in CI. Individual jobs may override this if
  # a particular check already passes -D warnings via its own flags.
  RUSTFLAGS: -D warnings

jobs:
  # ---------------------------------------------------------------------------
  # Format
  # ---------------------------------------------------------------------------
  fmt:
    name: Format
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: cargo fmt --all --check
        run: cargo fmt --all --check

  # ---------------------------------------------------------------------------
  # Clippy — host / emulator feature set
  #
  # We deliberately do NOT use --all-features here because `hardware` and
  # `emulator` are mutually exclusive in the firmware crate. Instead we lint
  # the workspace with the emulator feature set, which exercises all std-capable
  # code paths. The embedded code paths are covered by check-embedded below.
  #
  # firmware-ui is a cdylib. Passing --all-targets causes cargo to compile the
  # cdylib target on the host (fine), but combining `no-std` with `emulator`
  # features is contradictory, so we omit --all-features entirely.
  # ---------------------------------------------------------------------------
  clippy:
    name: Clippy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      # eink-emulator depends on winit/softbuffer which need wayland/x11 headers
      # at compile time (pkg-config build scripts). Install them here so clippy
      # can type-check the full workspace without skipping those crates.
      - name: Install Linux GUI dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            libwayland-dev \
            libxkbcommon-dev \
            libx11-dev \
            libxi-dev \
            libxrandr-dev

      # Lint all workspace crates that compile on the host (no cross-compilation).
      # Excludes the hardware-only firmware binary by using --lib instead of
      # --all-targets, which would try to compile required-features=["hardware"]
      # bins on a host target without an ARM toolchain.
      - name: cargo clippy (workspace, emulator features)
        run: |
          cargo clippy --workspace --lib --tests \
            -- -D warnings

      # Also lint firmware with the emulator feature set explicitly to catch
      # firmware-specific warnings in the emulator code paths.
      - name: cargo clippy -p firmware (emulator features)
        run: |
          cargo clippy -p firmware --lib \
            --features emulator,debug,keyboard-input \
            -- -D warnings

  # ---------------------------------------------------------------------------
  # Documentation build — warnings as errors
  #
  # RUSTDOCFLAGS="-D warnings" fails on broken intra-doc links, missing items
  # referenced in doc comments, and malformed code examples.
  #
  # --no-deps: only document workspace crates. Without this flag, a warning
  # in a transitive dependency's docs would break our build.
  # ---------------------------------------------------------------------------
  docs:
    name: Documentation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Install Linux GUI dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            libwayland-dev libxkbcommon-dev libx11-dev libxi-dev libxrandr-dev

      - name: cargo doc (warnings as errors)
        env:
          RUSTDOCFLAGS: -D warnings
        run: cargo doc --no-deps --workspace

  # ---------------------------------------------------------------------------
  # Tests — host-native, per crate
  #
  # cargo test --workspace --all-features is unsafe here because:
  #   1. `firmware` has required-features = ["hardware"] on its binary target,
  #      which needs an ARM toolchain not available on ubuntu-latest.
  #   2. Combining hardware+emulator features links cortex-m into a std binary,
  #      causing linker errors.
  #
  # Strategy: run tests for each testable crate individually with the correct
  # feature flags. Crates that are no_std-only and have no test logic are
  # checked via check-emulator / check-embedded instead.
  # ---------------------------------------------------------------------------
  test:
    name: Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      # eink-emulator is a direct test target and depends on winit/softbuffer
      # which need wayland/x11 headers to compile.
      - name: Install Linux GUI dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            libwayland-dev \
            libxkbcommon-dev \
            libx11-dev \
            libxi-dev \
            libxrandr-dev

      # platform: tests use tokio + embassy-time/std (configured in dev-dependencies)
      - name: cargo test -p platform
        run: cargo test -p platform

      # eink-specs: pure data crate, no_std compatible, tests run on host
      - name: cargo test -p eink-specs
        run: cargo test -p eink-specs

      # eink-system: pure layout engine, no external dev-deps beyond tokio
      - name: cargo test -p eink-system
        run: cargo test -p eink-system

      # eink-components: pure component library, no external dev-deps beyond tokio
      - name: cargo test -p eink-components
        run: cargo test -p eink-components

      # eink-emulator: std crate, tokio-based tests
      - name: cargo test -p eink-emulator
        run: cargo test -p eink-emulator

      # eink-testing: std crate
      - name: cargo test -p eink-testing
        run: cargo test -p eink-testing

      # firmware: lib tests only (no binary — that needs hardware features + ARM)
      # The lib target has no required-features so it compiles on host.
      - name: cargo test -p firmware --lib
        run: cargo test -p firmware --lib

      # firmware-ui: rlib target, no features needed for basic compilation
      - name: cargo test -p firmware-ui
        run: cargo test -p firmware-ui

  # ---------------------------------------------------------------------------
  # Emulator Build Check
  #
  # Verifies the desktop emulator compiles with the full feature set used by
  # `cargo dev` (xtask/src/dev.rs: "emulator,debug,keyboard-input").
  # Does not run the emulator (requires a display) — just checks it compiles.
  # ---------------------------------------------------------------------------
  check-emulator:
    name: Emulator Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      # Install system libraries required by winit/softbuffer on Linux
      - name: Install Linux GUI dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends \
            libwayland-dev \
            libxkbcommon-dev \
            libx11-dev \
            libxi-dev \
            libxrandr-dev

      - name: cargo check -p firmware (emulator features)
        run: |
          cargo check -p firmware \
            --features emulator,debug,keyboard-input

      # Also check that the display_emulator example resolves
      - name: cargo check display_emulator example
        run: |
          cargo check -p firmware \
            --example display_emulator \
            --features emulator,debug,keyboard-input

  # ---------------------------------------------------------------------------
  # Architecture Check
  #
  # Enforces dependency boundary rules for the vertical slice architecture:
  #
  #   Layer 1 (specs/primitives):
  #     eink-specs     — pure data, no display logic, no alloc
  #
  #   Layer 2 (engine):
  #     eink-system    — layout/styling; MUST NOT depend on eink-emulator
  #     eink-components — UI components; MUST NOT depend on eink-emulator
  #
  #   Layer 3 (simulation, std only):
  #     eink-emulator  — desktop emulator; MUST NOT depend on firmware
  #
  #   HAL layer (platform crate):
  #     platform       — hardware abstractions (traits); MUST NOT depend on firmware
  #                      (platform defines traits, firmware implements them)
  #
  # Rules enforced:
  #   1. eink-system + eink-components must not require eink-emulator
  #   2. eink-specs must not depend on eink-system, eink-emulator, or eink-components
  #   3. platform must not depend on firmware (HAL must not depend on app layer)
  #   4. eink-emulator must not depend on firmware (simulator is independent of app)
  # ---------------------------------------------------------------------------
  arch:
    name: Architecture
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Rule 1 — eink-system and eink-components must not require eink-emulator
        run: |
          # Violation: eink-emulator appears as a dev dep OR as a required
          # (non-optional) normal dep of eink-system or eink-components.
          # Allowed: optional dep behind the `examples` feature.
          VIOLATIONS=$(cargo metadata --format-version 1 | jq -r '
            .packages[] |
            select(.name == "eink-system" or .name == "eink-components") |
            .name as $pkg |
            .dependencies[] |
            select(.name == "eink-emulator") |
            select(.kind == "dev" or (.optional == false and .kind == null)) |
            "\($pkg) has forbidden dependency on eink-emulator (kind: \(.kind // "normal"), optional: \(.optional))"
          ')
          if [ -n "$VIOLATIONS" ]; then
            echo "Architecture violations (Rule 1):"
            echo "$VIOLATIONS"
            exit 1
          fi
          echo "OK (Rule 1): eink-system and eink-components have no required dependency on eink-emulator"

      - name: Rule 2 — eink-specs must not depend on higher-layer eink crates
        run: |
          # eink-specs is a pure data crate (no_std, no display logic).
          # It must not pull in eink-system, eink-emulator, or eink-components.
          VIOLATIONS=$(cargo metadata --format-version 1 | jq -r '
            .packages[] |
            select(.name == "eink-specs") |
            .name as $pkg |
            .dependencies[] |
            select(
              .name == "eink-system" or
              .name == "eink-emulator" or
              .name == "eink-components" or
              .name == "firmware"
            ) |
            "\($pkg) must not depend on \(.name) (layer boundary violation)"
          ')
          if [ -n "$VIOLATIONS" ]; then
            echo "Architecture violations (Rule 2):"
            echo "$VIOLATIONS"
            exit 1
          fi
          echo "OK (Rule 2): eink-specs has no upward dependencies"

      - name: Rule 3 — platform (HAL) must not depend on firmware (app)
        run: |
          # The platform crate defines hardware abstraction traits.
          # Firmware implements those traits. Platform must never depend on firmware
          # (that would be a circular dependency in the HAL layer).
          VIOLATIONS=$(cargo metadata --format-version 1 | jq -r '
            .packages[] |
            select(.name == "platform") |
            .name as $pkg |
            .dependencies[] |
            select(.name == "firmware") |
            "\($pkg) must not depend on firmware (HAL must not depend on app layer)"
          ')
          if [ -n "$VIOLATIONS" ]; then
            echo "Architecture violations (Rule 3):"
            echo "$VIOLATIONS"
            exit 1
          fi
          echo "OK (Rule 3): platform crate does not depend on firmware"

      - name: Rule 4 — eink-emulator must not depend on firmware
        run: |
          # The desktop emulator simulates display hardware — it is independent
          # of the DAP application firmware. If it depended on firmware, the
          # simulator could not be used as a standalone display dev tool.
          VIOLATIONS=$(cargo metadata --format-version 1 | jq -r '
            .packages[] |
            select(.name == "eink-emulator") |
            .name as $pkg |
            .dependencies[] |
            select(.name == "firmware") |
            "\($pkg) must not depend on firmware (emulator must be firmware-agnostic)"
          ')
          if [ -n "$VIOLATIONS" ]; then
            echo "Architecture violations (Rule 4):"
            echo "$VIOLATIONS"
            exit 1
          fi
          echo "OK (Rule 4): eink-emulator does not depend on firmware"

      - name: Verify vertical slice crate dependency graph
        run: |
          # Print the complete dependency summary for audit purposes.
          # This is informational; non-zero exit if workspace metadata fails.
          echo "=== Crate dependency summary ==="
          cargo metadata --format-version 1 | jq -r '
            .packages[] |
            select(
              .name == "eink-specs" or
              .name == "eink-system" or
              .name == "eink-components" or
              .name == "eink-emulator" or
              .name == "eink-testing" or
              .name == "platform" or
              .name == "firmware" or
              .name == "firmware-ui"
            ) |
            .name + " depends on: [" +
              ([.dependencies[] | select(.kind == null) | .name] | join(", ")) +
            "]"
          ' | sort

  # ---------------------------------------------------------------------------
  # cargo-deny — License, advisory, ban, and source checks
  #
  # Runs cargo-deny against the deny.toml at the repo root.
  # Enforces:
  #   advisories — deny known security vulnerabilities (RustSec advisory DB)
  #   bans       — deny minimp3 (unsound), epd-waveshare (wrong controller)
  #   licenses   — allow-list of OSI-approved licenses only
  #   sources    — deny crates from unknown registries or git sources
  #
  # NOTE: --all-features is intentionally NOT used here because `hardware`
  # and `emulator` are mutually exclusive in the firmware crate. Instead we
  # check the default feature set which covers all workspace crates that can
  # compile on the host without cross-compilation.
  # ---------------------------------------------------------------------------
  deny:
    name: cargo-deny
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2
      - uses: EmbarkStudios/cargo-deny-action@d8395c1c8c9df74d968a3bcbba5533e396ff43cf  # v2.0.9
        with:
          command: check advisories bans licenses sources

  # ---------------------------------------------------------------------------
  # Architecture boundary enforcement via cargo tree
  #
  # Verifies that banned crates (minimp3, epd-waveshare) are not in the
  # transitive dependency graph, and enforces layering rules from CLAUDE.md.
  #
  # These checks complement the metadata-based arch job above by catching
  # issues that appear only in the resolved dependency tree (not just the
  # declared [dependencies] in Cargo.toml).
  # ---------------------------------------------------------------------------
  arch-boundaries:
    name: Architecture boundaries
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: eink-specs must not depend on firmware
        run: |
          if cargo tree -p eink-specs 2>&1 | grep -q "firmware"; then
            echo "FAIL: eink-specs depends on firmware"
            exit 1
          fi
          echo "OK: eink-specs does not depend on firmware"

      - name: platform must not depend on firmware
        run: |
          if cargo tree -p platform 2>&1 | grep -q "^firmware\b"; then
            echo "FAIL: platform depends on firmware"
            exit 1
          fi
          echo "OK: platform does not depend on firmware"

      - name: epd-waveshare must not be in dependency graph
        run: |
          if cargo tree 2>&1 | grep -q "epd-waveshare"; then
            echo "FAIL: epd-waveshare found in dependency graph"
            exit 1
          fi
          echo "OK: epd-waveshare not present in dependency graph"

      - name: minimp3 must not be in dependency graph
        run: |
          if cargo tree 2>&1 | grep -q "minimp3"; then
            echo "FAIL: minimp3 found in dependency graph"
            exit 1
          fi
          echo "OK: minimp3 not present in dependency graph"

  # ---------------------------------------------------------------------------
  # Unsafe code audit — cargo-geiger
  #
  # Counts unsafe fn/impl/trait/block in workspace crates (not dependencies).
  # Fails if the count exceeds the baseline in .geiger-baseline.
  #
  # cargo-geiger requires Rust >= 1.85 to install; we use stable (not MSRV).
  # It analyses the codebase at whatever Rust version is installed.
  #
  # To update the baseline after intentionally adding new unsafe code:
  #   cargo geiger --output Json 2>/dev/null | python3 tools/geiger-count.py --check .geiger-baseline
  #   git add .geiger-baseline && git commit -m "chore: update geiger unsafe baseline"
  # ---------------------------------------------------------------------------
  geiger:
    name: Unsafe code audit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Install cargo-geiger
        run: cargo install cargo-geiger

      - name: Run unsafe code audit
        run: cargo geiger --output Json 2>/dev/null | python3 tools/geiger-count.py --check .geiger-baseline

  # ---------------------------------------------------------------------------
  # Embedded Check (STM32H7) — fast type/borrow check without linking
  #
  # `cargo check` validates types and borrows for the ARM target without
  # running the linker. This is fast but misses linker errors (undefined
  # symbols, section overflow, flip-link layout issues). The full link is
  # performed by the build-embedded job below.
  # ---------------------------------------------------------------------------
  check-embedded:
    name: Embedded Check (STM32H7)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: thumbv7em-none-eabihf

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: cargo check -p firmware (hardware, ARM target)
        run: |
          cargo check -p firmware \
            --target thumbv7em-none-eabihf \
            --features hardware

  # ---------------------------------------------------------------------------
  # No-std validation
  #
  # Verifies that embedded crates compile without std on the ARM Cortex-M7 target.
  # Catches std types (String, Vec, println!) accidentally added to no_std crates.
  # Uses the ARM target because some no_std issues only surface cross-compiling.
  #
  # Crate selection rationale:
  #   eink-specs       — pure data crate, no deps, expected no_std
  #   eink-system      — layout engine, no_std by design (uses heapless)
  #   eink-components  — UI components, no_std by design (uses heapless)
  #   platform         — HAL trait definitions, no_std (Embassy + embedded-hal)
  #   ui               — application UI state, #![cfg_attr(not(test), no_std)]
  #   playback         — audio engine, #![cfg_attr(not(test), no_std)]
  #   library          — music library, no_std (heapless collections)
  #   bluetooth        — BLE HCI, #![cfg_attr(not(test), no_std)]
  #   firmware-ui      — uses --features no-std (cdylib requires std on host by
  #                       default; the `no-std` feature activates #![no_std])
  # ---------------------------------------------------------------------------
  check-no-std:
    name: No-std validation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: thumbv7em-none-eabihf

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: eink-specs — no_std
        run: cargo check -p eink-specs --target thumbv7em-none-eabihf --no-default-features

      - name: eink-system — no_std
        run: cargo check -p eink-system --target thumbv7em-none-eabihf --no-default-features

      - name: eink-components — no_std
        run: cargo check -p eink-components --target thumbv7em-none-eabihf --no-default-features

      - name: platform — no_std
        run: cargo check -p platform --target thumbv7em-none-eabihf --no-default-features

      - name: ui — no_std
        run: cargo check -p ui --target thumbv7em-none-eabihf --no-default-features

      - name: playback — no_std
        run: cargo check -p playback --target thumbv7em-none-eabihf --no-default-features

      - name: library — no_std
        run: cargo check -p library --target thumbv7em-none-eabihf --no-default-features

      - name: bluetooth — no_std
        run: cargo check -p bluetooth --target thumbv7em-none-eabihf --no-default-features

      # firmware-ui is a cdylib that stays std on the host by default (so that
      # `cargo clippy --all-targets` compiles it without cross-compilation).
      # The `no-std` feature activates #![no_std]; we verify that path here.
      - name: firmware-ui — no_std (via --features no-std)
        run: cargo check -p firmware-ui --target thumbv7em-none-eabihf --no-default-features --features no-std

  # ---------------------------------------------------------------------------
  # Embedded Build (STM32H7) — full link with flip-link stack protection
  #
  # `cargo build` runs the full compilation + linker pipeline, which catches:
  #   - Undefined symbols (missing cortex-m-rt exception vectors)
  #   - Section overflow (firmware exceeds 2 MB flash limit)
  #   - flip-link layout errors (stack size + static footprint too large for RAM)
  #   - Linker script errors in memory.x
  #
  # `cargo check` (above) misses all of these because it skips the link step.
  #
  # flip-link is installed via `cargo install` because it is a standalone
  # linker binary, not a Rust library dependency. It is configured in
  # .cargo/config.toml as: linker = "flip-link" under [target.thumbv7em-none-eabihf].
  #
  # Binary size check: firmware must not exceed 2 MB (STM32H743ZI flash limit).
  # ---------------------------------------------------------------------------
  build-embedded:
    name: Embedded Build + Size Check (STM32H7)
    runs-on: ubuntu-latest
    needs: check-embedded   # Only full-build if fast check passes first
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: thumbv7em-none-eabihf

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Install flip-link (stack overflow protection linker)
        # flip-link is a standalone linker binary — NOT a Cargo library dep.
        # Configured in .cargo/config.toml: linker = "flip-link"
        # Ref: https://github.com/knurling-rs/flip-link
        run: cargo install flip-link

      - name: Install cargo-auditable
        # cargo-auditable embeds a compressed dependency manifest into the firmware ELF.
        # Enables post-deployment CVE scanning:
        #   cargo audit bin target/thumbv7em-none-eabihf/release/firmware
        # Critical for field-deployed units where Cargo.lock may not be available.
        # Ref: https://github.com/rust-secure-code/cargo-auditable
        run: cargo install cargo-auditable --locked

      - name: cargo build -p firmware (hardware, ARM target, release)
        # Full link: catches linker errors, section overflow, flip-link issues.
        # Uses --release to match the production build profile (LTO, opt-level=z).
        run: |
          cargo auditable build --release \
            --target thumbv7em-none-eabihf \
            --package firmware \
            --features hardware

      - name: Check firmware binary size (must not exceed 2 MB flash)
        run: |
          ELF=target/thumbv7em-none-eabihf/release/firmware
          if [ ! -f "$ELF" ]; then
            echo "ERROR: firmware ELF not found at $ELF"
            exit 1
          fi
          SIZE=$(stat -c%s "$ELF")
          echo "Firmware ELF size: $SIZE bytes"
          # 2 MB = 2097152 bytes. ELF includes debug symbols so the actual
          # flash usage is smaller (stripped .text+.rodata), but a >4 MB ELF
          # indicates something is very wrong with the build.
          MAX_ELF_SIZE=4194304  # 4 MB: conservative upper bound for ELF+debug
          if [ "$SIZE" -gt "$MAX_ELF_SIZE" ]; then
            echo "ERROR: Firmware ELF ($SIZE bytes) exceeds sanity limit ($MAX_ELF_SIZE bytes)"
            echo "Run: cargo size --release --target thumbv7em-none-eabihf -p firmware --features hardware -- -A"
            exit 1
          fi
          echo "OK: firmware ELF size $SIZE bytes is within limits"

  # ---------------------------------------------------------------------------
  # Clippy — embedded target (thumbv7em-none-eabihf)
  #
  # Runs clippy for the ARM embedded target, which catches embedded-specific
  # issues that host clippy misses (unsafe DMA patterns, no_std constraints,
  # cortex-m peripheral access patterns).
  #
  # Separate from the host clippy job because:
  #   1. Requires ARM target installation
  #   2. Uses --no-default-features to avoid std deps
  #   3. Requires flip-link to resolve linker configuration
  # ---------------------------------------------------------------------------
  clippy-embedded:
    name: Clippy (embedded target)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: thumbv7em-none-eabihf
          components: clippy

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Install flip-link
        run: cargo install flip-link

      - name: Clippy firmware (embedded target)
        run: |
          cargo clippy \
            --package firmware \
            --target thumbv7em-none-eabihf \
            --no-default-features \
            --features hardware \
            -- -D warnings

      - name: Clippy platform (embedded target, no-default-features)
        run: |
          cargo clippy \
            --package platform \
            --target thumbv7em-none-eabihf \
            --no-default-features \
            -- -D warnings

  # ---------------------------------------------------------------------------
  # Binary size check — arm-none-eabi-size (text+data sections)
  #
  # Uses arm-none-eabi-size to measure actual flash section sizes, which is
  # more accurate than the ELF file size (which includes debug symbols).
  #
  # The text section = flash usage. Fail if it exceeds 1.8 MB to leave 200 KB
  # headroom in the 2 MB flash for future growth and OTA staging.
  #
  # Runs independently of build-embedded (parallel CI) for faster feedback.
  # ---------------------------------------------------------------------------
  binary-size:
    name: Binary size check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: thumbv7em-none-eabihf

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Install tools
        run: |
          cargo install flip-link
          sudo apt-get install -y binutils-arm-none-eabi

      - name: Build firmware
        run: |
          cargo build \
            --package firmware \
            --release \
            --target thumbv7em-none-eabihf \
            --no-default-features \
            --features hardware

      - name: Check binary size (arm-none-eabi-size, flash section)
        run: |
          ELF=target/thumbv7em-none-eabihf/release/firmware
          arm-none-eabi-size $ELF
          # Extract text section size (flash usage)
          TEXT=$(arm-none-eabi-size $ELF | tail -1 | awk '{print $1}')
          echo "Flash usage (text): ${TEXT} bytes"
          # Fail if over 1.8 MB (leaves 200 KB headroom in 2 MB flash)
          MAX=1887436  # 1.8 * 1024 * 1024
          if [ "$TEXT" -gt "$MAX" ]; then
            echo "ERROR: Flash usage ${TEXT} exceeds limit ${MAX}"
            exit 1
          fi
          echo "OK: ${TEXT} bytes of ${MAX} bytes limit used"

  # ---------------------------------------------------------------------------
  # MSRV — Minimum Supported Rust Version
  #
  # Reads rust-version from Cargo.toml and compiles with that exact toolchain.
  # Prevents silent breakage when users upgrade their toolchain; ensures the
  # firmware compiles with the oldest supported Rust version.
  #
  # Embassy requires ~1.75+ for async fn in traits. Update rust-version in
  # Cargo.toml when intentionally adopting newer language features.
  # ---------------------------------------------------------------------------
  msrv:
    name: Minimum Supported Rust Version
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Get MSRV from Cargo.toml
        id: msrv
        run: |
          MSRV=$(grep 'rust-version' Cargo.toml | head -1 | sed 's/.*= *"\([^"]*\)".*/\1/')
          echo "msrv=$MSRV" >> $GITHUB_OUTPUT
          echo "MSRV: $MSRV"

      - uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ steps.msrv.outputs.msrv }}

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Check workspace with MSRV toolchain
        run: cargo check --workspace

  # ---------------------------------------------------------------------------
  # Unused dependencies — cargo machete
  #
  # cargo machete detects dependencies declared in Cargo.toml that are not
  # actually used in any source file. Unused deps waste compile time and bloat
  # the dependency graph.
  #
  # Some embedded-only deps (defmt, cortex-m-rt, panic-probe) appear unused
  # to machete because they are used via link-time magic or cfg(target_arch).
  # These are suppressed via .cargo-machete.toml at the repo root.
  # ---------------------------------------------------------------------------
  unused-deps:
    name: Unused dependencies
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Install cargo-machete
        run: cargo install cargo-machete

      - name: Check for unused dependencies
        run: cargo machete

  # ---------------------------------------------------------------------------
  # Lint coverage — every crate must opt into workspace lints
  #
  # Without [lints]\nworkspace = true, the safety lints defined in
  # [workspace.lints] (arithmetic_side_effects, indexing_slicing,
  # unsafe_op_in_unsafe_fn) are silently inactive in that crate. This job
  # catches any new crate that forgets to add the opt-in.
  # ---------------------------------------------------------------------------
  lint-coverage:
    name: All crates opt into workspace lints
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Verify workspace lint opt-in
        run: |
          # Every crate Cargo.toml must have [lints] workspace = true.
          # grep -L prints files that do NOT match.
          MISSING=$(grep -rL "workspace = true" \
            crates/*/Cargo.toml \
            crates/*/*/Cargo.toml \
            xtask/Cargo.toml \
            2>/dev/null | grep -v "target/")
          if [ -n "$MISSING" ]; then
            echo "ERROR: The following Cargo.toml files are missing [lints] workspace = true:"
            echo "$MISSING"
            echo ""
            echo "Add the following to each missing Cargo.toml:"
            echo ""
            echo "  [lints]"
            echo "  workspace = true"
            exit 1
          fi
          echo "OK: All crates opt into workspace lints"

  # ---------------------------------------------------------------------------
  # Documentation tests (GAP-L4)
  #
  # `cargo test --doc` runs all code examples in `///` and `//!` doc comments.
  # Doc examples are part of the public API contract: if they fail to compile
  # or produce wrong output, the documentation is misleading. Without this job
  # they bitrot silently when APIs change.
  #
  # Only host-compilable crates are included here. Skipped crates:
  #   eink-emulator  — requires a windowing system (no display in CI)
  #   firmware        — no_std, doc tests not supported on embedded target
  #   firmware-ui     — cdylib + no_std via feature; doc tests run as rlib below
  # ---------------------------------------------------------------------------
  doc-tests:
    name: Documentation tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Run doc tests (host-compilable crates)
        run: |
          # Doc tests for crates that compile on the host without a display.
          # cargo test --doc compiles and runs every ``` code block in /// comments.
          cargo test --doc -p platform
          cargo test --doc -p eink-specs
          cargo test --doc -p eink-system
          cargo test --doc -p eink-components
          cargo test --doc -p eink-testing
          cargo test --doc -p firmware-ui

  # ---------------------------------------------------------------------------
  # Supply chain security (GAP-L3)
  #
  # `cargo audit` checks Cargo.lock against the RustSec advisory database and
  # fails the build if any dependency has a known CVE or security advisory.
  #
  # Without this step, CVEs disclosed after a field deployment require manual
  # cross-referencing of the advisory database against the dependency graph —
  # which is error-prone and slow. CI automation catches vulnerabilities on
  # every PR before they reach a build artifact.
  #
  # Note on cargo-auditable:
  #   `cargo-auditable` embeds a compressed dependency manifest into ELF
  #   binaries, enabling `cargo audit bin <elf>` on field-deployed firmware.
  #   The embedded manifest covers the exact dependency tree frozen at build
  #   time — critical for post-deployment CVE disclosure on deployed units.
  #   Install via: cargo install cargo-auditable
  #   Use via:     cargo auditable build --release ...
  #   Audit ELF:   cargo audit bin target/.../firmware
  #
  # cargo audit (below) checks Cargo.lock for pre-deployment CVE scanning.
  # cargo-auditable ELF embedding is now done in the build-embedded job above.
  # Use: cargo audit bin target/thumbv7em-none-eabihf/release/firmware
  # ---------------------------------------------------------------------------
  supply-chain:
    name: Supply chain security
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - uses: dtolnay/rust-toolchain@stable

      - uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2

      - name: Install cargo-audit
        run: cargo install cargo-audit --locked

      - name: Run cargo audit (RustSec advisory database)
        # Checks Cargo.lock against known CVEs and security advisories.
        # --deny warnings turns advisory warnings into hard failures.
        # Remove --deny warnings if a dependency has an unfixed advisory
        # and you need to suppress it with an ignore entry in audit.toml.
        run: cargo audit
